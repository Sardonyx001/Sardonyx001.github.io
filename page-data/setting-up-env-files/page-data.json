{"componentChunkName":"component---src-templates-blog-post-js","path":"/setting-up-env-files/","result":{"data":{"site":{"siteMetadata":{"title":"FunctionalBits()"}},"markdownRemark":{"id":"9296ccab-c842-525f-8032-53be4c5b8ce5","excerpt":"When dealing with multiple Bash scripts that interact with the same API endpoint, maintaining consistency in configuration settings like port numbers and URLsâ€¦","html":"<p>When dealing with multiple Bash scripts that interact with the same API endpoint, maintaining consistency in configuration settings like port numbers and URLs can be a headache when you have to update each file everytime.</p>\n<p>An easy way to solve this is to use a .env (.env.local) file where you define all your repeating values and then source said file in each script (which you only have to do once!).</p>\n<ol>\n<li>\n<p>In the same directory as your script files make a new file called <code class=\"language-text\">.env[.local]</code> or just <code class=\"language-text\">.env</code></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># .env.local</span>\n<span class=\"token assign-left variable\">API_URL</span><span class=\"token operator\">=</span><span class=\"token string\">\"https://api.example.com\"</span>\n<span class=\"token assign-left variable\">API_PORT</span><span class=\"token operator\">=</span><span class=\"token number\">8080</span>\n</code></pre></div>\n</li>\n<li>\n<p>Add the following line at the top of your scripts</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">source</span> <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">dirname</span> $<span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token variable\">)</span></span>/.env.local\"</span></code></pre></div>\n</li>\n</ol>\n<p>So what are we doing here? why not just <code class=\"language-text\">source .env.local</code>?</p>\n<p>The problem with the latter is when you call your script from any other directory then it will just error out a <code class=\"language-text\">.env.local: No such file or directory</code> as the <code class=\"language-text\">source</code> command is expecting the file to be in the <code class=\"language-text\">pwd</code>, which we can quickly verify by include <code class=\"language-text\">pwd</code> at the top of a script and calling it from somewhere else.</p>\n<p>Thus, to get the original directory from wherever we are calling the script we get the script path from <code class=\"language-text\">$0</code> and get the path without the filename with the <code class=\"language-text\">dirname</code> command.</p>\n<p>This may seem like a very trivial thing but I spent a good amount of time wondering why it was telling me the file doesn't exist when it clearly does.</p>\n<p>I hope this saves you some headaches.</p>","frontmatter":{"title":"Setting up convenient .env files","date":"August 30, 2023","description":"Simplifying Configuration in Bash Scripts Using .env Files"}},"previous":{"fields":{"slug":"/using-jq-to-parse-json/"},"frontmatter":{"title":"Using jq to parse JSON from the comfort of your own terminal"}},"next":{"fields":{"slug":"/cmake-is-annoying:-stuff-to-pay-attentio/"},"frontmatter":{"title":"Cmake is annoying: stuff to pay attention to when using cmake"}}},"pageContext":{"id":"9296ccab-c842-525f-8032-53be4c5b8ce5","previousPostId":"2ffefb09-828d-59c0-931d-2dc0f366e98d","nextPostId":"ec83f0ba-82af-5c1c-9c0e-b8411d713d68"}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}